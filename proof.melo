type U4 = {0..15}
type U8 = {0..255}

# def node2hash(node: [U8; $n]) =
#     if $n < 32 then keccak256(node) else node

# def skip_partial_path<$k, $p>(partial_path: [$p], key: [$k + 1], nib_idx: {0..$k}) =
#     for i in range($p) fold accum = 0 with accum + if partial_path[i] == key[nib_idx + i] then 1 else fail!

# todo once bytestring slicing is implemented
# def proof2list() =
#     unsafe let byte = ((vref(env_spender_tx().outputs, 0) :! CoinData).additional_data :! %[1])[0] in
#     if byte < 248 # short list

# todo: remove offset and just send slice without length bytes?
def branch_next<$n>(branch: %[$n + 1], offset: {0..$n}, nibble: U8) =
    #unsafe let next_hash = x"" :! %[32] in
    unsafe let next_hash = 0 :! U8 in
    let node_idx = 0 :! U4 in
    let len_byte = 0 :! Nat in
    loop 16 do
        len_byte <- branch[offset];
        next_hash <- if nibble == node_idx then branch[(offset + 1) :! {0..$n}] else next_hash;
        offset <- if len_byte == 128 then (offset + 1) :! {0..$n} else (offset + 33) :! {0..$n};
        node_idx <- (node_idx + 1) :! U4
    return next_hash

def to_nibbles(key: %[32]): [U4; 64] =
  unsafe let nibbles = [] :! [U4; 64] in
  let idx = 0 :: {0..63} in
  loop 64 do
    nibbles <- (nibbles ++ [
      if idx % 2 then key[(idx / 2) :! {0..31}] & 15
      else (key[(idx / 2) :! {0..31}] & 240) >> 4
    ]) :! [U4; 64];
    idx <- (idx + 1) :! {0..63}
  return nibbles

# def next<$n>(node: %[$n + 1], nibbles: [U4; 64], nib_idx: {0..31}): %[32] =
#   let node_len = $n + 1 in
#   if node_len > 257 then let offset = 3 in offset
#   else if node_len > 56 then let offset = 2 in offset
#   else let offset = 1 in offset

def decode_node<$n, $p>(rlp_node: %[$n + 1]) = #: [%[]; $p] =
  unsafe let node = [] :! [%[]; $p] in
  let item_len = 0 :! Nat in
  let node_len = $n + 1 in
  let offset = (if node_len > 257 then 3
  else if node_len > 56 then 2
  else 1) :! {0..$n} in
  loop 16 do
    item_len <- (if offset < node_len then rlp_node[offset] - 128 else item_len);
    node <- if offset < node_len then node ++ [rlp_node[offset + 1..offset + 1 + item_len]] else node;
    offset <- (offset + 1 + item_len) :! {0..$n} # todo: more efficient to check if or to add?
  return node

---

let branch = x"f90191a04afdeba7fefb0adc262f8b41452c9ce478f9d8ab7e34e9bd71b28da9c326d597a0e044dc0b5d7263dbca3a9aa87d794c52b495b1c380b36d24031ea7821a8b6171a0c05131dde6a35de1d85a562aa250fbc076a6777d02685de0433c4c52911682ef80a0c356e1beccd5e77a7300c1dcd1a808ae07e732deacd8eef49f1eda4a65946b1980a00a4c0e6429c4a1e71c2ae1bb6d2427b7e7978a56aed7c86ac50a6329d648b906a0435ed0af602b5b9e15ed439d005df0a32ce1b9c271c47e5576300b07e18ae4dba0" ++ x"149056551322ade0bef850c8ff53bf8bcf1975fec7c911a076d26c02339d533fa0bc0f060fd16dfaa54ae8135854089476d4da361e5881fd3e93fb8a8a5d851886a0153da6d2c71e70f1ad0020f1663643cc24cc00bdb04c11e87ffd5c483533cdd9a096916e8044b53837df860e191a35cc2629f2d3395bb17a71cbaa28e301b7deaf80a05e85ac83ff5fbf667b66c3f414229be180f414f52f6b0f86cb180db20e4087b8a0c6cb4cbfa178826be44e45cc060323d2a99cc94f326c174b6b83a4d7045ba4028080" in
let key = x"e5fba075a7dc86558f1f4a176586d7472af44ef89cbf49a835e9967def28b92f" in
#branch_next(branch, 3, 14)
    #next(branch, )
decode_node(branch)
