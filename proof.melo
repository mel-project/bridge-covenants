type NLandML = [MetaLen, NodeLen]
type MetaLen = {0..3}
type Node = [%[];]
type NodeLen = {0..516}
type Proof = %[16384]
type ProofIndex = {0..16383}
type U4 = {0..15}

def get_additional_data() =
  unsafe (vref(env_spender_tx().outputs, 0) :! CoinData).additional_data

def proof2nodes() =
    unsafe let proof = get_additional_data() :! Proof in
    let offset = 0 :: ProofIndex in
    let nodes = [] :: Node in
    let nodelen_and_metalen = [0, 0] :: NLandML in
    loop 64 do
      nodelen_and_metalen <- if offset < blen(proof) then (
          if proof[offset] == 249 then [b2n(x"000000000000000000000000000000000000000000000000000000000000" ++ unsafe_bslice(proof, offset + 1, offset + 3) :! %[2])] ++ [3]
          else if proof[offset] == 248 then [proof[(offset + 1) :! ProofIndex]] ++ [2]
          else [proof[offset] - 192] ++ [1]
        ) :! NLandML
        else nodelen_and_metalen;
      nodes <- if offset < blen(proof)
        then nodes ++ [unsafe_bslice(proof, extern call "print"(offset + nodelen_and_metalen[1]) :! Nat, extern call "print"(offset + nodelen_and_metalen[0] + nodelen_and_metalen[1]) :! Nat)] :! Node
        else nodes;
      offset <- if offset < blen(proof)
        then (offset + nodelen_and_metalen[0] + nodelen_and_metalen[1]) :! ProofIndex
        else offset
    return nodes

def decode_node<$n>(rlp_node: %[$n + 1]) =
  unsafe let node = [] :! Node in
  let node_len = $n + 1 in
  let item_len = 0 :! Nat in
  let offset = (
    if node_len > 257 then 3
    else if node_len > 56 then 2
    else 1
  ) :! {0..$n} in
  loop 17 do
    item_len <- if offset < node_len then rlp_node[offset] - 128 else item_len;
    node <- if offset < node_len then node ++ [unsafe_bslice(rlp_node, offset + 1, offset + 1 + item_len)] :: Node else node;
    offset <- (offset + 1 + item_len) :! {0..$n} # todo: more efficient to check if or to add?
  return node

def to_nibbles(key: %[32]): [U4; 64] =
  unsafe let nibbles = [] :! [U4; 64] in
  let idx = 0 :: {0..63} in
  loop 64 do
    nibbles <- (nibbles ++ [
      if idx % 2 then key[(idx / 2) :! {0..31}] & 15
      else (key[(idx / 2) :! {0..31}] & 240) >> 4
    ]) :! [U4; 64];
    idx <- (idx + 1) :! {0..63}
  return nibbles

---

proof2nodes()